akka {
  loggers = [akka.event.slf4j.Slf4jLogger]
  loglevel = "DEBUG"
  log-config-on-start = off
  stdout-loglevel = off

  log-dead-letters = 10
  log-dead-letters-during-shutdown = on

  persistence {
    # Path to the journal plugin to be used
    journal.plugin = "pg-journal"
    # Path to the snapshot store plugin to be used
    snapshot-store.plugin = "pg-snapshot"

    pg.journal.query {
      class = "akka.persistence.pg.journal.query.PostgresReadJournalProvider"
      write-plugin = "pg-journal"
      refresh-interval = 3s
      max-buffer-size = 100
    }
  }


  actor {
    debug {
      # enable function of LoggingReceive, which is to log any received message at DEBUG level
      # receive = on
      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
      # autoreceive = on
      # enable DEBUG logging of actor lifecycle changes
      # lifecycle = on
      # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
      # fsm = on
      # enable DEBUG logging of subscription changes on the eventStream
      # event-stream = on
    }
  }

}

pg-journal {
  # Class name of the plugin.
  class = "be.wegenenverkeer.mosaic.infrastructure.CustomPgAsyncWriteJournal"
  # Dispatcher for the plugin actor.
  plugin-dispatcher = "akka.actor.default-dispatcher"
}

# My custom snapshot store plugin
pg-snapshot {
  # Class name of the plugin.
  class = "akka.persistence.pg.snapshot.PgAsyncSnapshotStore"
  # Dispatcher for the plugin actor.
  plugin-dispatcher = "akka.persistence.dispatchers.default-plugin-dispatcher"
}

pg-persistence {

  pgjson = "jsonb"

  db {
    user = ${slick.dbs.default.db.user}
    password = ${slick.dbs.default.db.password}
    url = ${slick.dbs.default.db.url}
    connectionPool = "HikariCP"
    numThreads = 2
    connectionTimeout = 5 seconds
  }
  journalSchemaName = "public"
  journalTableName = "journal"
  snapshotSchemaName = "public"
  snapshotTableName = "snapshot"

  writestrategy = "akka.persistence.pg.journal.TableLockingWriteStrategy"

  eventstore {

    encoder: "be.wegenenverkeer.mosaic.infrastructure.JsValueEncoder"
    tagger: "be.wegenenverkeer.mosaic.infrastructure.EventTagger"
    class: ""   #no event store class
    useView: false # if false events will be read directly from the journal, if true you need to create a view
    #on the journal table that only shows the events
    eventViewSchema: ""
    eventViewName: "events"
  }
}
